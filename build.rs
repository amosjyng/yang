use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

/// Which OS we're running on -- not the OS that we're targeting for potential cross-compilation.
#[cfg(target_os = "linux")]
const CURRENT_OS: &str = "linux";
#[cfg(target_os = "macos")]
const CURRENT_OS: &str = "mac";
#[cfg(target_os = "windows")]
const CURRENT_OS: &str = "windows";

/// The filename extension for the yang executable.
#[cfg(target_family = "unix")]
const BINARY_EXT: &str = "";
#[cfg(target_family = "windows")]
const BINARY_EXT: &str = ".exe";

/// The version of the Yang that will be used to generate build files.
const YANG_DEP_VERSION: &str = "0.0.2";

/// Build `yang` using itself.
fn main() {
    // no need to regenerate autogenerated files every time
    println!("cargo:rerun-if-changed=build.rs");
    // do rerun if autogenerated file gets removed
    println!("cargo:rerun-if-changed=src/concepts/attributes/target.rs");

    let out_dir = env::var("OUT_DIR").unwrap();
    let yang_binary = format!("{}/yang-v{}{}", out_dir, YANG_DEP_VERSION, BINARY_EXT);

    if Path::new(&yang_binary).exists() {
        println!("Yang executable already exists at {}", yang_binary);
    } else {
        let yang_url = format!(
            "https://bintray.com/amosjyng/zamm/download_file?file_path=yang%2F{}%2F{}%2Fyang{}",
            YANG_DEP_VERSION, CURRENT_OS, BINARY_EXT
        );

        println!("Bintray URL determined to be {}", yang_url);
        println!("Yang executable will be saved locally to {}", yang_binary);

        Command::new("wget")
            .args(&["-O", yang_binary.as_str(), yang_url.as_str()])
            .output()
            .expect(
                format!(
                    "Can't download yang version {} from Bintray.",
                    YANG_DEP_VERSION
                )
                .as_str(),
            );

        if fs::metadata(&yang_binary).unwrap().len() == 0 {
            fs::remove_file(&yang_binary).unwrap();
            panic!(
                "FAILURE: yang version downloaded from {} is empty.",
                yang_url
            );
        }
    }

    Command::new("chmod")
        .args(&["+x", yang_binary.as_str()])
        .output()
        .expect(
            format!(
                "Could not add execute permissions to yang binary located at {}",
                yang_binary
            )
            .as_str(),
        );

    println!("==================== RUNNING YANG ====================");

    let result = Command::new(yang_binary.as_str())
        .args(&[
            "Target",
            "--id",
            "2",
            "-d",
            "The target of an implement command.",
        ])
        .output()
        .expect(
            format!(
                "Could not generate attribute `Target` using yang binary located at {}",
                yang_binary
            )
            .as_str(),
        );

    print!("{}", std::str::from_utf8(&result.stdout).unwrap());
}
