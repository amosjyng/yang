/// Mark files as autogenerated.
pub mod mark_autogen;
/// Mark lines as not needing formatting.
///
/// Sometimes, it's just too hard to autogenerate perfectly formatted code.
pub mod mark_fmt;

use super::CodegenConfig;
use mark_autogen::add_autogeneration_comments;
use mark_fmt::add_fmt_skips;

/// Do post-processing on generated code. Includes marking lines with autogeneration comments, or
/// marking lines as requiring formatting skips.
pub fn post_process_generation(code: &str, options: &CodegenConfig) -> String {
    let formatted = add_fmt_skips(&code);
    if options.comment_autogen && !options.release {
        add_autogeneration_comments(&formatted)
    } else {
        formatted
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::string_format::tao::code_tao;
    use crate::codegen::string_format::FormatConfig;
    use crate::codegen::{StructConfig, CodeConfig};
    use mark_autogen::AUTOGENERATION_MARKER;
    use mark_fmt::FMT_SKIP_MARKER;

    #[test]
    fn test_post_process_comments() {
        let code = code_tao(&FormatConfig::default());
        let result = post_process_generation(&code, &CodegenConfig::default());
        assert!(result.contains(AUTOGENERATION_MARKER));
        assert!(result.contains("YIN_MAX_ID"));
    }

    #[test]
    fn test_post_process_no_comments() {
        let code_cfg = &CodeConfig {
            codegen_cfg: CodegenConfig {
                comment_autogen: false,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_tao(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains(AUTOGENERATION_MARKER));
    }

    #[test]
    fn test_post_process_yin() {
        let code_cfg = &CodeConfig {
            codegen_cfg: CodegenConfig {
                yin: true,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_tao(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains("YIN_MAX_ID"));
    }

    #[test]
    fn test_post_process_fmt_not_skip() {
        let code_cfg = &CodeConfig {
            target: StructConfig {
                name: "S".to_owned(), // short
                ..StructConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_tao(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains(FMT_SKIP_MARKER));
    }

    #[test]
    fn test_post_process_fmt_skip() {
        let code_cfg = &CodeConfig {
            target: StructConfig {
                name: "ReallySuperLongClassNameOhBoy".to_owned(), // short
                ..StructConfig::default()
            },
            codegen_cfg: CodegenConfig {
                release: false,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_tao(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(result.contains(FMT_SKIP_MARKER));
    }

    #[test]
    fn test_post_process_fmt_skip_release() {
        let code_cfg = &CodeConfig {
            target: StructConfig {
                name: "ReallySuperLongClassNameOhBoy".to_owned(), // short
                ..StructConfig::default()
            },
            codegen_cfg: CodegenConfig {
                release: true,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_tao(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(result.contains(FMT_SKIP_MARKER));
    }
}
