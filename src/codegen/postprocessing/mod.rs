/// Mark files as autogenerated.
pub mod mark_autogen;
/// Mark lines as not needing formatting.
///
/// Sometimes, it's just too hard to autogenerate perfectly formatted code.
pub mod mark_fmt;

use super::CodegenConfig;
pub use crate::codegen::name_transform::NameTransform;
use crate::codegen::string_format::attribute::code_attribute;
use crate::codegen::string_format::code_string_concept;
use crate::codegen::string_format::tao::code_tao;
use crate::codegen::string_format::FormatConfig;
use crate::concepts::ImplementConfig;
use mark_autogen::add_autogeneration_comments;
use mark_fmt::add_fmt_skips;

/// Configuration settings for generating a single concept's contents.
pub struct CodeConfig<'a> {
    /// Name of the concept to generate.
    pub name: &'a str,
    /// Name of the concept's parent.
    pub parent_name: &'a str,
    /// Concept-specific implementation settings.
    pub impl_cfg: ImplementConfig,
    /// Code generation settings for all concepts.
    pub codegen_cfg: CodegenConfig,
}

impl<'a> Default for CodeConfig<'a> {
    fn default() -> Self {
        Self {
            name: "dummy",
            parent_name: "Tao",
            impl_cfg: ImplementConfig::default(),
            codegen_cfg: CodegenConfig::default(),
        }
    }
}

/// Do post-processing on generated code. Includes marking lines with autogeneration comments, or
/// marking lines as requiring formatting skips.
fn post_process_generation(code: &str, options: &CodegenConfig) -> String {
    let formatted = add_fmt_skips(&code);
    if options.comment_autogen && !options.release {
        add_autogeneration_comments(&formatted)
    } else {
        formatted
    }
}

/// Generate the final version of code, to be output to a file as-is.
pub fn code(cfg: &CodeConfig) -> String {
    let format_cfg = FormatConfig::from(cfg);
    let initial_code = if cfg.parent_name == "Attribute" {
        code_attribute(&format_cfg)
    } else if cfg.parent_name == "Data" {
        code_string_concept(&format_cfg)
    } else {
        code_tao(&format_cfg)
    };
    post_process_generation(&initial_code, &cfg.codegen_cfg)
}

#[cfg(test)]
mod tests {
    use super::*;
    use mark_autogen::AUTOGENERATION_MARKER;
    use mark_fmt::FMT_SKIP_MARKER;

    #[test]
    fn test_post_process_comments() {
        let code = code_attribute(&FormatConfig::default());
        let result = post_process_generation(&code, &CodegenConfig::default());
        assert!(result.contains(AUTOGENERATION_MARKER));
        assert!(result.contains("YIN_MAX_ID"));
    }

    #[test]
    fn test_post_process_no_comments() {
        let code_cfg = &CodeConfig {
            codegen_cfg: CodegenConfig {
                comment_autogen: false,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_attribute(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains(AUTOGENERATION_MARKER));
    }

    #[test]
    fn test_post_process_yin() {
        let code_cfg = &CodeConfig {
            codegen_cfg: CodegenConfig {
                yin: true,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_attribute(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains("YIN_MAX_ID"));
    }

    #[test]
    fn test_post_process_fmt_not_skip() {
        let code_cfg = &CodeConfig {
            name: "short",
            ..CodeConfig::default()
        };
        let code = code_attribute(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(!result.contains(FMT_SKIP_MARKER));
    }

    #[test]
    fn test_post_process_fmt_skip() {
        let code_cfg = &CodeConfig {
            name: "ReallySuperLongClassNameOhBoy",
            codegen_cfg: CodegenConfig {
                release: false,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_attribute(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(result.contains(FMT_SKIP_MARKER));
    }

    #[test]
    fn test_post_process_fmt_skip_release() {
        let code_cfg = &CodeConfig {
            name: "ReallySuperLongClassNameOhBoy",
            codegen_cfg: CodegenConfig {
                release: true,
                ..CodegenConfig::default()
            },
            ..CodeConfig::default()
        };
        let code = code_attribute(&FormatConfig::from(code_cfg));
        let result = post_process_generation(&code, &code_cfg.codegen_cfg);
        assert!(result.contains(FMT_SKIP_MARKER));
    }
}
