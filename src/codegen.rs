/// Generate code for attribute files.
mod attribute;
/// Format documentation as rustdoc.
mod docstring;
/// Mark files as autogenerated.
mod mark_autogen;

use crate::concepts::Documentable;
use crate::concepts::Implement;
use attribute::code_attribute;
use docstring::into_docstring;
use mark_autogen::add_autogeneration_comments;
use path_abs::PathAbs;
use std::fs;
use std::path::Path;
use std::rc::Rc;
use zamm_yin::wrappers::CommonNodeTrait;

/// Output code to filename
fn output_code(name: &str, doc: Option<Rc<String>>, id: usize, comment_autogen: bool) {
    let generated_code = code_attribute(name, doc, id, comment_autogen);
    let file_relative = format!("src/concepts/attributes/{}.rs", name.to_lowercase());
    let file_pathabs = PathAbs::new(Path::new(&file_relative))
        .expect(format!("Could not get absolute path for {}", file_relative).as_str());
    let file_absolute = file_pathabs.as_path().to_str().unwrap();
    let file_parent = file_pathabs
        .as_path()
        .parent()
        .expect(format!("Could not get parent directory for {}", file_absolute).as_str());
    fs::create_dir_all(file_parent).expect(
        format!(
            "Could not create intermediate directories for {}",
            file_absolute
        )
        .as_str(),
    );
    fs::write(file_absolute, generated_code)
        .expect(format!("Couldn't output generated code to {}", file_absolute).as_str());
    println!("Generated {}", file_absolute);
}

/// Handle the implementation request for a new attribute archetype.
pub fn handle_implementation(request: Implement, id: usize, comment_autogen: bool) {
    let target = request.target().unwrap();
    output_code(
        &target.internal_name().unwrap(),
        target.documentation(),
        id,
        comment_autogen,
    )
}
